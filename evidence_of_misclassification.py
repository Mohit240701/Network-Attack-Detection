# -*- coding: utf-8 -*-
"""Evidence of Misclassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1clyGJEIWiY1iI0DAZJtfUCW-1gjMEC4d
"""

import os
import re
import time
import pandas as pd
import numpy as np
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
import seaborn as sns
import random
import tensorflow as tf

import matplotlib.pyplot as plt
from sklearn.metrics import f1_score, classification_report

# Loading dataset
df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/Dataset_S022Final.csv")
# Dropped sendTime, sender, reciever, IP_src, port_src, IP_dest, port_dest, Frequency
df=df[['Next_Current_diff','Next_Pre_diff','SNext_Current_diff','SNext_Pre_diff','rcvdPK','duration(ms)','packet_type','droppedPKWrongPort','sentPK','size','channel','DataQueueLen','passedUpPk','rcvdPKFromHL','rcvdPKFromLL','sentDownPK','DropPKByQueue','snir','throughput','label']]
# One hot encoding label
df = pd.get_dummies(df, columns = ['label'])

# Filter the DDOS dataset and obtain its index in the complete dataset
DDOS = df[df['label_DDOS_UDP_FLOOD']==1]
# Modifying the 'size' feature in DDOS labelled data
df_mod = df*1
for i in DDOS.index:
  df_mod.at[i, 'size'] = random.uniform(0, 0.12)
# Obtain the 5 sample of DDOS labelled data
DDOS_sample = df_mod[df_mod['label_DDOS_UDP_FLOOD']==1].head()
# Create input from DDOS sample
X_DDOS_sample = DDOS_sample.drop(columns = ['label_BROUILLAGE_Trafic','label_DDOS_UDP_FLOOD','label_Normal','label_PLUIES_ET_ORAGES'])
y_DDOS_sample = DDOS_sample[['label_BROUILLAGE_Trafic','label_DDOS_UDP_FLOOD','label_Normal','label_PLUIES_ET_ORAGES']]
# Input for actual dataset
X_test = df.drop(columns = ['label_BROUILLAGE_Trafic','label_DDOS_UDP_FLOOD','label_Normal','label_PLUIES_ET_ORAGES'])
y_test = df[['label_BROUILLAGE_Trafic','label_DDOS_UDP_FLOOD','label_Normal','label_PLUIES_ET_ORAGES']]
# Input for modified dataset
X_mod_test = df_mod.drop(columns = ['label_BROUILLAGE_Trafic','label_DDOS_UDP_FLOOD','label_Normal','label_PLUIES_ET_ORAGES'])
y_mod_test = df_mod[['label_BROUILLAGE_Trafic','label_DDOS_UDP_FLOOD','label_Normal','label_PLUIES_ET_ORAGES']]

# Loading trained model
model = tf.keras.models.load_model('/content/drive/MyDrive/Colab Notebooks/CNN_Classification.keras')
# Predicting output using DDOS sample
y_DDOS_predict = model.predict(X_DDOS_sample)
print('Correct label: \n[Jamming,DDOS,Normal,Weather]\n')
print(np.array(y_DDOS_sample), '\n')
print('Predicted label: \n[Jamming,DDOS,Normal,Weather]\n')
print(y_DDOS_predict, '\n')

# Overall performance of the model with original input
y_predict = model.predict(X_test)
# Modify the output into binary form, highest probablity output = 1, otherwise 0
for j in range(len(y_predict)):
    curr_row = y_predict[j][:]
    max_val = max(curr_row)
    max_loc = np.where(curr_row == max_val)[0]
    for k in range(len(curr_row)):
      y_predict[j][k] = 0
    y_predict[j][max_loc] = 1
print('Performance matrix of original input: \n', classification_report(y_test, y_predict, target_names =['Jamming','DDOS','Normal','Weather']))

# Overall performance of the model with adversarial input
y_mod_predict = model.predict(X_mod_test)
# Modify the output into binary form, highest probablity output = 1, otherwise 0
for j in range(len(y_mod_predict)):
    curr_row = y_mod_predict[j][:]
    max_val = max(curr_row)
    max_loc = np.where(curr_row == max_val)[0]
    for k in range(len(curr_row)):
      y_mod_predict[j][k] = 0
    y_mod_predict[j][max_loc] = 1
print('Performance matrix of adversarial input: \n', classification_report(y_mod_test, y_mod_predict, target_names =['Jamming','DDOS','Normal','Weather']))